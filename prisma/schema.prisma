// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Workspace {
  id                   String   @id @default(uuid()) @db.Uuid
  name                 String
  createdAt            DateTime @default(now())
  llm_annotation_limit Int      @default(3)
  llm_annotation_used  Int      @default(0)

  users       User[]
  transcripts Transcripts[]

  @@map("Workspaces")
}


model User {
  id            String   @id @default(uuid()) @db.Uuid
  workspace_id  String   @db.Uuid
  name          String
  username      String
  password      String
  auth_user_id  String?  @unique
  role          Role     @default(llm)
  createdAt     DateTime @default(now())
  lastLogin     DateTime?
  workspace     Workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
  transcripts   Transcripts[]
  annotations   Annotations[]
  notes         Notes[]
  flagAssignments FlagAssignments[]
  llmNotePrompts LLMNotePrompts[]
  scavengerHuntAssignments ScavengerHuntAssignment[]

  @@unique([workspace_id, username])
}

model Transcripts {
  id                          String   @id @default(uuid()) @db.Uuid
  workspace_id                String   @db.Uuid
  uploaded_by                 String   @db.Uuid
  title                       String
  grade                       String?
  instruction_context         String
  transcript_file_name        String?   @db.Text
  gcs_path                    String   @db.Text
  upload_time                 DateTime @default(now())
  llm_annotation              LLMAnnotationStatus @default(not_generated)
  llm_annotation_visibility_default      LLMAnnotationVisibilityAdmin @default(hidden)
  llm_annotation_visibility_per_annotator Boolean @default(false)
  video_uploaded              Boolean  @default(false)
  video_id                    String?  @unique @db.Uuid
  annotation_file_name        String?   @db.Text
  llm_annotation_gcs_path     String?  @db.Text
  instructional_material_link String? @db.Text
  workspace                   Workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
  uploader                    User    @relation(fields: [uploaded_by], references: [id])
  video                       Videos? @relation("TranscriptVideo", fields: [video_id], references: [id])
  materials                   InstructionalMaterial[]
  lines                       TranscriptLines[]
  annotations                 Annotations[]
  scavengerHunt               ScavengerHunt?
  segments                    TranscriptSegments[]
  notes                       Notes[]
  llmNotePrompts             LLMNotePrompts[]

  @@map("Transcripts")
}

model Notes {
  note_id       String      @id @default(uuid()) @db.Uuid
  user_id       String      @db.Uuid
  transcript_id String      @db.Uuid
  note_number   Int
  title         String
  q1            String      @db.Text
  q2            String      @db.Text
  q3            String      @db.Text
  source        NoteSource  @default(user)
  createdAt     DateTime    @default(now())
  user          User        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  transcript    Transcripts @relation(fields: [transcript_id], references: [id], onDelete: Cascade)
  assignments   NoteAssignments[]

  @@map("Notes")
}

model NoteAssignments {
  note_id String          @db.Uuid
  line_id String          @db.Uuid
  createdAt DateTime      @default(now())
  note    Notes           @relation(fields: [note_id], references: [note_id], onDelete: Cascade)
  line    TranscriptLines @relation(fields: [line_id], references: [line_id], onDelete: Cascade)

  @@id([note_id, line_id])
  @@map("NoteAssignments")
}

model FlagAssignments {
  user_id String          @db.Uuid
  line_id String          @db.Uuid
  createdAt DateTime      @default(now())
  user    User            @relation(fields: [user_id], references: [id], onDelete: Cascade)
  line    TranscriptLines @relation(fields: [line_id], references: [line_id], onDelete: Cascade)

  @@id([user_id, line_id])
  @@map("FlagAssignments")
}

model InstructionalMaterial {
  id            String        @id @default(uuid()) @db.Uuid
  transcript_id String        @db.Uuid
  gcs_path      String        @db.Text
  image_title   String        @db.Text
  order_index   Int
  uploaded_at   DateTime      @default(now())
  transcript    Transcripts   @relation(fields: [transcript_id], references: [id], onDelete: Cascade)
}

model Annotations {
  id            String            @id @default(uuid()) @db.Uuid
  transcript_id String            @db.Uuid
  created_for   String            @db.Uuid
  hide                 Boolean?          @default(false)
  annotation_completed Boolean           @default(false)
  llm_annotation_visibility_admin LLMAnnotationVisibilityAdmin @default(hidden)
  llm_annotation_visibility_user  Boolean @default(true)
  gcs_path             String            @db.Text
  upload_time          DateTime          @default(now())
  last_updated         DateTime          @updatedAt
  transcript           Transcripts       @relation(fields: [transcript_id], references: [id])
  user                 User              @relation(fields: [created_for], references: [id])

  @@map("Annotations")
}

model ScavengerHunt {
  id            String   @id @default(uuid()) @db.Uuid
  transcript_id String   @unique @db.Uuid

  scavenger_visibility_admin LLMAnnotationVisibilityAdmin @default(hidden)
  scavenger_visibility_user  Boolean @default(false)

  createdAt DateTime @default(now())

  transcript  Transcripts @relation(fields: [transcript_id], references: [id], onDelete: Cascade)
  questions   ScavengerHuntQuestion[]
  assignments ScavengerHuntAssignment[]

  @@map("ScavengerHunts")
}

model ScavengerHuntAssignment {
  id            String   @id @default(uuid()) @db.Uuid
  scavenger_id  String   @db.Uuid
  created_for   String   @db.Uuid

  scavenger_completed Boolean @default(false)

  scavenger_visibility_admin LLMAnnotationVisibilityAdmin @default(hidden)
  scavenger_visibility_user  Boolean @default(false)

  assigned_time DateTime @default(now())
  completedAt   DateTime?

  scavenger ScavengerHunt @relation(fields: [scavenger_id], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [created_for], references: [id], onDelete: Cascade)
  answers   ScavengerHuntAnswer[]

  @@unique([scavenger_id, created_for])
  @@map("ScavengerHuntAssignments")
}

model ScavengerHuntQuestion {
  id            String @id @default(uuid()) @db.Uuid
  scavenger_id  String @db.Uuid

  question      String @db.Text
  order_index   Int

  scavenger ScavengerHunt @relation(fields: [scavenger_id], references: [id], onDelete: Cascade)
  answers   ScavengerHuntAnswer[]

  @@unique([scavenger_id, order_index])
  @@map("ScavengerHuntQuestions")
}

model ScavengerHuntAnswer {
  id             String @id @default(uuid()) @db.Uuid
  assignment_id  String @db.Uuid
  question_id    String @db.Uuid

  answer         String? @db.Text
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  assignment ScavengerHuntAssignment @relation(fields: [assignment_id], references: [id], onDelete: Cascade)
  question   ScavengerHuntQuestion   @relation(fields: [question_id], references: [id], onDelete: Cascade)
  lines      ScavengerHuntAnswerLines[]

  @@unique([assignment_id, question_id])
  @@map("ScavengerHuntAnswers")
}

model ScavengerHuntAnswerLines {
  answer_id String @db.Uuid
  line_id   String @db.Uuid

  answer ScavengerHuntAnswer @relation(fields: [answer_id], references: [id], onDelete: Cascade)
  line   TranscriptLines    @relation(fields: [line_id], references: [line_id], onDelete: Cascade)

  @@id([answer_id, line_id])
  @@map("ScavengerHuntAnswerLines")
}

model TranscriptLines {
  line_id       String      @id @default(uuid()) @db.Uuid
  transcript_id String      @db.Uuid
  segment_id    String?     @db.Uuid
  line          Int
  speaker       String?
  utterance     String?     @db.Text
  in_cue        Decimal?    @db.Decimal(10, 2)
  out_cue       Decimal?    @db.Decimal(10, 2)
  transcript    Transcripts @relation(fields: [transcript_id], references: [id], onDelete: Cascade)
  segmentRef    TranscriptSegments? @relation(fields: [segment_id], references: [id], onDelete: SetNull)
  noteAssignments NoteAssignments[]
  flagAssignments FlagAssignments[]
  scavengerHuntAnswerLines ScavengerHuntAnswerLines[]

  @@map("TranscriptLines")
}

model Videos {
  id            String      @id @default(uuid()) @db.Uuid
  file_name     String      @db.Text
  mime_type     String?     @db.Text
  gcs_path      String      @db.Text
  uploaded_at   DateTime    @default(now())
  transcript    Transcripts? @relation("TranscriptVideo")

  @@map("Videos")
}

model TranscriptSegments {
  id            String      @id @default(uuid()) @db.Uuid
  transcript_id String      @db.Uuid
  segment_title String      @db.Text
  segment_index Int
  start_time    Decimal?    @db.Decimal(10, 2)
  end_time      Decimal?    @db.Decimal(10, 2)
  transcript    Transcripts @relation(fields: [transcript_id], references: [id], onDelete: Cascade)
  lines         TranscriptLines[]

  @@map("TranscriptSegments")
}

model LLMNotePrompts {
  id                     String   @id @default(uuid()) @db.Uuid
  transcript_id          String   @db.Uuid
  created_by             String   @db.Uuid

  note_creation_prompt   String   @db.Text
  note_assignment_prompt String   @db.Text

  annotate_all_lines     Boolean  @default(true)

  range_start_line       Int?
  range_end_line         Int?

  createdAt              DateTime @default(now())

  transcript Transcripts @relation(fields: [transcript_id], references: [id], onDelete: Cascade)
  user       User        @relation(fields: [created_by], references: [id], onDelete: Cascade)

  @@map("LLMNotePrompts")
}

enum Role {
  llm
  annotator
  admin
}

enum NoteSource {
  user
  llm
}

enum LLMAnnotationVisibilityAdmin {
  hidden
  visible_after_completion
  always_visible
}

enum LLMAnnotationStatus {
  not_generated
  in_process
  generated
}
